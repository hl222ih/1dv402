<link rel="import" href="../bower_components/polymer/polymer.html">
<link rel="import" href="../bower_components/paper-slider/paper-slider.html"/>
<link rel="import" href="one-week.html"/>
<link rel="import" href="one-shift.html"/>
<link rel="import" href="one-employee.html"/>
<link rel="import" href="one-delete.html"/>
<link rel="import" href="../bower_components/paper-button/paper-button.html"/>
<link rel="import" href="../bower_components/core-splitter/core-splitter.html"/>
<link rel="import" href="../bower_components/core-collapse/core-collapse.html"/>
<link rel="import" href="../bower_components/core-range/core-range.html"/>
<link rel="import" href="../bower_components/paper-dialog/paper-action-dialog.html"/>
<link rel="import" href="../bower_components/paper-input/paper-input-decorator.html"/>
<link rel="import" href="../bower_components/core-selector/core-selector.html"/>
<link rel="import" href="../bower_components/core-icons/core-icons.html">

<polymer-element unresolved name="one-schedule" horizontal layout>
    <template>
        <link rel="stylesheet" href="one-schedule.css" type="text/css">
        <div vertical layout style="width: 80%; height: 100%;">
            <div id="headerContainer" style="display: block; width: 98%; max-height: 10%;">
                <one-delete id="oneDelete" dragInfo="{{dragInfo}}"></one-delete>
                <div id="scheduleSelectContainer" class="selectContainer">
                    <paper-button raised>Logga&nbsp;in</paper-button><!--om ej inloggad-->
                    <paper-button raised>Spara</paper-button><!--om schema är laddat-->
                    <paper-button raised style="clear: none;" on-click="{{clearPlaced}}">Rensa</paper-button><!--om schema är laddat-->
                    <paper-button raised on-click="{{editSettings}}">Inställningar</paper-button><!--om schema är laddat-->
                    <paper-button raised>Tidigare version</paper-button><!--om schema är laddat-->
                    <paper-button raised on-click="{{openLoadScheduleDialog}}">Ladda schema</paper-button>
                </div>
                <div id="employeeSelectContainer" class="selectContainer">
                    <template repeat="{{employee in schedule.employees}}">
                        <one-employee id="oneEmployee" class="employeeData" on-click="{{editEmployee}}" employee="{{employee}}" dragInfo="{{dragInfo}}" style="background-color: {{employee.bgColor}};"></one-employee>
                    </template>
                    <paper-button raised on-click="{{editEmployee}}">Ny anställd</paper-button>
                </div>
                <div id="shiftSelectContainer" class="selectContainer">
                    <template repeat="{{shift in schedule.shiftDefinitions}}">
                        <one-shift id="oneShift" class="shiftData" on-click="{{editShift}}" shift="{{shift}}" dragInfo="{{dragInfo}}" style="background-color: #eee"></one-shift>
                    </template>
                    <paper-button raised on-click="{{editShift}}">Ny tur</paper-button>
                </div>
            </div>
            <div flex id="scheduleContainer" style="margin: 1%; width: 98%; maxHeight: 200px">
                <paper-button id="printButton" raised onclick="window.print()">Skriv&nbsp;ut</paper-button>
                <paper-slider id="paperSlider" min="140" max="900" value="[[pxWeekWidth]]" immediateValue="{{pxWeekWidth}}"></paper-slider>
                <template repeat="{{weekSchedule, index in schedule.weekSchedules}}">
                    <one-week id="oneWeek" data="{{weekSchedule}}" pxWidth="{{pxWeekWidth}}" pxHeight="{{pxWeekHeight}}" weekNumber="{{index + 1}}" layout="{{schedule.weekSchedules.length}}" dragInfo="{{dragInfo}}"></one-week>
                </template>
            </div>
            <paper-action-dialog id="editSettingsDialog" heading="Rensa?"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]">
                <p>Hmm</p>
                <paper-button dismissive default>Avbryt</paper-button>
                <paper-button id="editScheduleButton" affirmative on-click="{{clearPlacedEmployees}}">Skapa schema</paper-button>
            </paper-action-dialog>
            <paper-action-dialog id="clearPlacedDialog" heading="Rensa?"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]">
                <p>Schemat kommer att rensas på utplacerade turer/anställda.</p>
                <paper-button dismissive default>Avbryt</paper-button>
                <paper-button id="clearPlacedShiftsButton" affirmative on-click="{{clearPlacedShifts}}">Rensa turer och anställda</paper-button>
                <paper-button id="clearPlacedEmployeesButton" affirmative on-click="{{clearPlacedEmployees}}">Rensa endast anställda </paper-button>
            </paper-action-dialog>
            <paper-action-dialog id="deleteEmployeeDialog" heading="Radera anställd?"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]">
                <p>Alla inställningar och utplaceringar av den anställda kommer att försvinna.</p>
                <paper-button dismissive default>Avbryt</paper-button>
                <paper-button id="deleteEmployeeButton" affirmative>Radera</paper-button>
            </paper-action-dialog>
            <paper-action-dialog id="deleteShiftDialog" heading="Radera tur?"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]">
                <p>Alla inställningar och utplaceringar av turen kommer att försvinna.</p>
                <paper-button dismissive default>Avbryt</paper-button>
                <paper-button id="deleteShiftButton" affirmative>Radera</paper-button>
            </paper-action-dialog>
            <paper-action-dialog id="editEmployeeDialog" heading="Ändra anställd"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]"
                                 autoCloseDisabled="true">
                <template bind="{{editedEmployee as employee}}">
                    <paper-input-decorator label="Namn" floatingLabel="true" style="display: block;" error="{{employee.nameError}}" focused>
                        <input is="core-input" value="{{employee.name}}" on-blur="{{validateInput}}" data-type="employeeName" autofocus>
                    </paper-input-decorator>
                    <paper-input-decorator label="Kod" floatingLabel="true" style="display: block;" error="{{employee.codeError}}">
                        <input is="core-input" value="{{employee.code}}" on-blur="{{validateInput}}" data-type="employeeCode">
                    </paper-input-decorator>
                    <paper-input-decorator label="Heltidsarbetstidsmått (timmar/vecka)" floatingLabel="true" style="display: block;" error="{{employee.weekWorkHoursError}}">
                        <input is="core-input" value="{{employee.weekWorkHours}}" on-blur="{{validateInput}}" data-type="employeeWeekWorkHours">
                    </paper-input-decorator>
                    <paper-input-decorator label="Anställningsgrad (procent)" floatingLabel="true" style="display: block;" error="{{employee.employmentPercentageError}}">
                        <input is="core-input" value="{{employee.employmentPercentage}}" on-blur="{{validateInput}}" data-type="employeeEmploymentPercentage">
                    </paper-input-decorator>
                    <paper-button on-click="{{randomizeEmployeeColor}}" style="background-color: {{employee.bgColor}}">Ändra färg</paper-button>
                    <paper-button dismissive default>Avbryt</paper-button>
                    <paper-button id="saveEmployeeButton" affirmative on-click="{{saveEmployeeChanges}}">Spara</paper-button>
                </template>
            </paper-action-dialog>
            <paper-action-dialog id="editShiftDialog" heading="Ändra tur"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]"
                                 autoCloseDisabled="true">
                <template bind="{{editedShift as shift}}">
                    <paper-input-decorator label="Kod" floatingLabel="true" style="display: block;" error="{{shift.codeError}}" focused>
                        <input is="core-input" value="{{shift.code}}" on-blur="{{validateInput}}" data-type="shiftCode" autofocus>
                    </paper-input-decorator>
                    <paper-input-decorator label="Starttid" floatingLabel="true" style="display: block;" error="{{shift.startTimeError}}">
                        <input is="core-input" value="{{shift.startTimeText}}" on-blur="{{validateInput}}" data-type="shiftStartTime">
                    </paper-input-decorator>
                    <paper-input-decorator label="Sluttid" floatingLabel="true" style="display: block;" error="{{shift.endTimeError}}">
                        <input is="core-input" value="{{shift.endTimeText}}" on-blur="{{validateInput}}" data-type="shiftEndTime">
                    </paper-input-decorator>
                    <paper-button dismissive default>Avbryt</paper-button>
                    <paper-button id="saveShiftButton" affirmative on-click="{{saveShiftChanges}}">Spara</paper-button>
                </template>
            </paper-action-dialog>
            <paper-action-dialog id="loadScheduleDialog" heading="Ladda schema"
                                 transition="core-transition-top" layered="true"
                                 backdrop="true" closeSelector="[dismissive]"
                                 autoCloseDisabled="true" style="min-width: 30%">
                    <core-selector id="scheduleSelector" valueattr="label" selectedClass="core-selected">
                        <template repeat="{{scheduleName in scheduleNames}}">
                            <div on-click="{{selectSchedule}}" label="{{scheduleName}}">{{scheduleName}}</div>
                        </template>
                    </core-selector>
                <paper-button dismissive default>Avbryt</paper-button>
                <paper-button id="loadScheduleButton" affirmative on-click="{{loadSchedule}}">Ladda schema</paper-button>
            </paper-action-dialog>

        </div>
        <core-splitter id="splitter" direction="left" allowOverflow="true"></core-splitter>
        <div flex id="infoContainer" style="font-family: 'Trebuchet MS', Helvetica, sans-serif; overflow-y: auto;">
            <template repeat="{{employee, index in schedule.employees}}">
                <div on-click="{{toggle}}" style="padding: 1px; padding-left: 5px; border: 1px solid #dedede; background-color: {{employee.bgColor}}">
                    {{employee.name}} ({{employee.code}})
                    <template if="{{employee.hoursPlanned < employee.lowerDeviationLimit}}">
                        <core-icon style="background-color: greenyellow" icon="expand-less"></core-icon>
                    </template>
                    <template if="{{employee.hoursPlanned >= employee.lowerDeviationLimit && employee.leftToPlan > 0}}">
                        <core-icon style="background-color: yellow" icon="expand-less"></core-icon>
                    </template>
                    <template if="{{employee.hoursPlanned <= employee.upperDeviationLimit && employee.leftToPlan < 0}}">
                        <core-icon style="background-color: yellow" icon="expand-more"></core-icon>
                    </template>
                    <template if="{{employee.hoursPlanned > employee.upperDeviationLimit}}">
                        <core-icon style="background-color: orangered" icon="expand-more"></core-icon>
                    </template>
                    {{employee.leftToPlan}}
                </div>
                <core-collapse style="padding-left: 2px; font-size: 10px;">
                    <div>Timmar kvar att lägga ut: {{employee.leftToPlan}}</div>
                    <div>Utlagda timmar: {{employee.hoursPlanned}} (av {{employee.totalHours}})</div>
                    <div>Utlagd procent: {{employee.percentagePlanned}} % (av {{employee.employmentPercentage}} %)</div>
                    <div>Utlagda turer: {{employee.numberOfShifts}} ( {{employee.hoursPerShift}} timmar / tur)</div>
                </core-collapse>
            </template>
        </div>
    </template>
    <script src="../bower_components/svg.js/dist/svg.js"></script>
    <script>
        (function() {
            'use strict';
            var MINUTES_IN_A_DAY = 1440;
            var MINUTES_IN_AN_HOUR = 60;
            var DAYS_IN_A_WEEK = 7;
            var toTwoDecimals = function(num) {
                return Math.round(num * 100) / 100; //at most 2 decimals
            };

            function Employee(employeeData) {
                employeeData = employeeData || {};
                this.code = employeeData.code || "";
                this.name = employeeData.name || "";
                this.color = employeeData.color || "black";
                this.bgColor = employeeData.bgColor || "white";
                this.weekWorkHours = employeeData.weekWorkHours || 37; //veckoarbetstidsmått, default 37 timmar per vecka (vid heltidsarbete)
                this.employmentPercentage = employeeData.employmentPercentage || 100; //tjänstgöringsgrad, default 100% (heltid)
            }

            function Schedule(scheduleData) {
                scheduleData = scheduleData || {};
                this.name = scheduleData.name || "";
                this.numberOfWeeks = scheduleData.numberOfWeeks || 0;
                this.weekSchedules = [];
                this.shiftDefinitions = [];
                this.employeesCodes = scheduleData.employeesCodes || [];
                this.employees = getEmployeesFromCodes(scheduleData.employeesCodes);

                for (var i = 0; i < this.numberOfWeeks; i++) {
                    this.weekSchedules.push({shifts: []});
                }

                scheduleData.shiftDefinitions = scheduleData.shiftDefinitions || [];
                scheduleData.shiftDefinitions.forEach(function (shiftDefinitionData) {
                    this.shiftDefinitions.push(new ShiftDefinition(shiftDefinitionData));
                },this);

                scheduleData.shifts = scheduleData.shifts || [];
                scheduleData.shifts.forEach(function (shiftData) {
                    var shiftDefinition = this.shiftDefinitions.filter(function (shiftDefinition) {
                        return shiftDefinition.code === shiftData.shiftCode;
                    })[0];
                    for (var i = 0; i < shiftData.weeks.length; i++) {
                        shiftData.week = shiftData.weeks[i];
                        shiftData.shiftDefinition = shiftDefinition;

                        var shift = new Shift(shiftData);
                        this.addEmployeesToShift(shift, shiftData.employeeCodes);

                        this.weekSchedules[shift.week - 1].shifts.push(shift);
                        if (shift.endTime < shift.startTime) {
                            if (shift.dayOfWeek === 7) {
                                if (shift.week !== this.numberOfWeeks) {
                                    this.weekSchedules[shift.week].shifts.push(shift);
                                } else {
                                    this.weekSchedules[0].shifts.push(shift);
                                }
                            }
                        }
                    }
                }, this);
                this.breakPointTime = 20.5 * MINUTES_IN_AN_HOUR; //todo: allow user to set schedule's break point time
            }

            function Shift(shiftData) {
                shiftData = shiftData || {};
                this.code = shiftData.shiftCode || "";
                this.employees = [];
                this.workPlace = workplacesData.filter(function (workplaceData) {
                    return workplaceData.code === shiftData.workplaceCode;
                })[0] || {};
                this.weeks = shiftData.weeks || [1];
                this.week = shiftData.week || this.weeks[0];
                this.startTime = shiftData.shiftDefinition ? shiftData.shiftDefinition.startTime : 0 || 0;
                this.endTime = shiftData.shiftDefinition ? shiftData.shiftDefinition.endTime : 0 || 0 ;
                this.dayOfWeek = shiftData.dayOfWeek || 1;
                this.numberOfShiftsWideForFirst = 1; //not settable on creation (1 means full width, 3 means 1/3 of full width)
                this.numberOfShiftsWideForSecond = 1; //not settable on creation (if shift spans over two days, this is the part for day 2)
                this.positionForFirst = 1; //not settable on creation (if width is 3, 1 means to the left, 2 in the middle, 3 to the right of available width)
                this.positionForSecond = 1; //not settable on creation (if shift spans over two days, this is the position for the part of the shift on day 2)
                this.fulfillsDayRestConstraint = true;
            }

            function ShiftDefinition(shiftDefinitionData) {
                shiftDefinitionData = shiftDefinitionData || {};
                this.code = shiftDefinitionData.code || "";
                this.workPlace = workplacesData.filter(function (workplaceData) {
                    return workplaceData.code === shiftDefinitionData.workplaceCode;
                })[0] || {};
                this.startTime = shiftDefinitionData.startTime || 0;
                this.endTime = shiftDefinitionData.endTime || 0;
                this.week = undefined; //is set when dropped on a weekDay
                this.dayOfWeek = undefined; //is set when dropped on a weekDay
            }

            Schedule.prototype.updateShifts = function() {
                this.numberOfShifts = this.getAllShifts().length;
            };

            Schedule.prototype.updateEmployees = function() {
                this.employees.forEach( function(employee) {
                    var totalHours = this.getEmployeeTotalHours(employee);
                    employee.totalHours = toTwoDecimals(totalHours);
                    employee.percentagePlanned = toTwoDecimals(this.getEmployeePercentagePlanned(employee));
                    var hoursPlanned = this.getEmployeeHoursPlanned(employee);
                    employee.hoursPlanned = toTwoDecimals(hoursPlanned);
                    employee.numberOfShifts = this.getEmployeeNumberOfShifts(employee);
                    employee.hoursPerShift = employee.numberOfShifts > 0 ? toTwoDecimals(hoursPlanned/employee.numberOfShifts) : "-";
                    var leftToPlan = totalHours - this.numberOfWeeks * 1.5 - hoursPlanned; //todo: add "1.5" as schedule setting
                    employee.leftToPlan = toTwoDecimals(leftToPlan);
                    var allowedDeviationHoursPerWeek = 1.0; //todo: add as schedule setting
                    var allowedDeviationHours = this.numberOfWeeks * allowedDeviationHoursPerWeek;
                    employee.upperDeviationLimit = totalHours - this.numberOfWeeks * 1.5 + allowedDeviationHours;
                    employee.lowerDeviationLimit = totalHours - this.numberOfWeeks * 1.5 - allowedDeviationHours;
                    employee.hasOwnBreakPoint = false; //todo: allow employee to have own break point time
                }, this);
            };

            Schedule.prototype.getEmployeeTotalHours = function(employee) {
                return employee.weekWorkHours * employee.employmentPercentage / 100 * this.numberOfWeeks;
            };

            Schedule.prototype.getEmployeePercentagePlanned = function(employee) {
                var totalHours = this.getEmployeeHoursPlanned(employee);
                var numberOfWeeks = this.numberOfWeeks;
                var weekWorkHours = employee.weekWorkHours;
                var totalPercentage = totalHours / numberOfWeeks / weekWorkHours * 100;
                return totalPercentage;
            };

            Schedule.prototype.getEmployeeHoursPlanned = function (employee) {
                var shifts = [];
                var weekSchedules = [];
                var minutes = 0;
                var hours;

                shifts = this.getEmployeeShifts(employee);

                //make sure to not count a shift twice, when it spans over multiple weeks.
                var seen = [];
                shifts.forEach( function (shift) {
                    if (seen.indexOf(shift) === -1) {
                        seen.push(shift);
                        if (shift.endTime > shift.startTime) {
                            minutes = minutes + shift.endTime - shift.startTime;
                        } else {
                            minutes = minutes + shift.endTime + MINUTES_IN_A_DAY - shift.startTime;
                        }
                    }
                });

                hours = minutes / MINUTES_IN_AN_HOUR;
                return hours;
            };

            Schedule.prototype.getAllShifts = function() {
                var shifts = [];

                this.weekSchedules.forEach( function (weekSchedule) {
                    weekSchedule.shifts.forEach( function (shift) {
                        if (shifts.indexOf(shift) === -1) {
                            shifts.push(shift);
                            //shifts = shifts.concat(weekSchedule.shifts);
                        }
                    });
                });
                return shifts;
            };

            Schedule.prototype.getShiftsByCode = function(code) {
                var shifts = [];

                this.weekSchedules.forEach( function (weekSchedule) {
                    weekSchedule.shifts.forEach( function (shift) {
                        if (shift.code === code && shifts.indexOf(shift) === -1) {
                            shifts.push(shift);
                        }
                    });
                });
                return shifts;
            };

            Schedule.prototype.getShiftsByEmployee = function (employee) {
                var shifts = [];

                this.weekSchedules.forEach( function (weekSchedule) {
                    weekSchedule.shifts.forEach( function (shift) {
                        if (shift.employees.indexOf(employee) !== -1 && shifts.indexOf(shift) === -1) {
                            shifts.push(shift);
                        }
                    })
                });
                return shifts;
            };

            Schedule.prototype.getEmployeeByCode = function(code) {
                return this.employees.filter( function(employee) {
                    return employee.code === code;
                })[0];
            };

            Schedule.prototype.getShiftDefinitionByCode = function(code) {
                return this.shiftDefinitions.filter( function (shiftDef) {
                    return shiftDef.code === code;
                })[0];
            };

            Schedule.prototype.getEmployeeShifts = function (employee) {
                var shifts = [];
                var filteredShifts = [];

                this.weekSchedules.forEach( function (weekSchedule) {
                    shifts = shifts.concat(weekSchedule.shifts);
                });
                filteredShifts = shifts.filter( function (shift) {
                    return shift.employees.indexOf(employee) !== -1;
                });

                return filteredShifts;
            };

            Schedule.prototype.getEmployeeNumberOfShifts = function(employee) {
                var shifts = [];
                var weekSchedules = [];
                var numShifts = 0; //number of shifts

                shifts = this.getEmployeeShifts(employee);
                //make sure to not count a shift twice, when it spans over multiple weeks.
                var seen = [];
                shifts.forEach( function (shift) {
                    if (seen.indexOf(shift) === -1) {
                        seen.push(shift);
                        numShifts++;
                    }
                });

                return numShifts;
            };

            Schedule.prototype.deleteShift = function(shift) {
                var isDeleted = false;

                this.weekSchedules.forEach( function (weekSchedule) {
                    var indexOfShift = weekSchedule.shifts.indexOf(shift);
                    if (indexOfShift !== -1) {
                        weekSchedule.shifts.splice(indexOfShift, 1);
                        isDeleted = true;
                    }
                });

                return isDeleted;
            };

            Schedule.prototype.deleteShiftDefinition = function(shiftDefinition) {
                var isDeleted = false,
                    indexOfShiftDefinition = this.shiftDefinitions.indexOf(shiftDefinition);

                if (indexOfShiftDefinition !== -1) {
                    this.shiftDefinitions.splice(indexOfShiftDefinition, 1);
                    isDeleted = true;
                }

                return isDeleted;
            };

            Schedule.prototype.addEmployeesToShift = function(shift, employeeCodes) {
                employeeCodes.forEach( function (empCode) {
                    var employee = this.employees.filter( function(employee) {
                        return empCode === employee.code;
                    })[0];
                    if (employee) {
                        shift.employees.push(employee);
                    }
                },this);
            };

            ShiftDefinition.prototype.createShift = function() {
                var shift = new Shift();
                shift.startTime = this.startTime;
                shift.endTime = this.endTime;
                shift.code = this.code;
                shift.workPlace = this.workPlace;
                shift.week = this.week;
                shift.dayOfWeek = this.dayOfWeek;
                return shift;
            };

            Shift.prototype.getAdjustedStartTime = function (dayOfWeek) {
                var startTime;

                if (this.startTime < this.endTime) {
                    //shift within same day
                    startTime = this.startTime;
                } else {
                    //shift spans over two days
                    if (this.dayOfWeek === dayOfWeek) {
                        //use first part of shift (i.e. [22:00]-00:00)
                        startTime = this.startTime;
                    } else {
                        //use second part of shift (i.e. [00:00]-06:00)
                        startTime = 0;
                    }
                }

                return startTime;
            };

            Shift.prototype.getAdjustedEndTime = function (dayOfWeek) {
                var endTime;

                if (this.startTime < this.endTime) {
                    //shift within same day
                    endTime = this.endTime;
                } else {
                    //shift spans over two days
                    if (this.dayOfWeek === dayOfWeek) {
                        //use first time of shift (i.e. 22:00-[00:00])
                        endTime = MINUTES_IN_A_DAY;
                    } else {
                        //use second time of shift (i.e. 00:00-[06:00])
                        endTime = this.endTime;
                    }
                }

                return endTime;
            };

            Shift.prototype.isFirstOrSecondEvaluated = function(dayOfWeek) {
                var result = "first";

                if (this.startTime >= this.endTime && this.dayOfWeek !== dayOfWeek) {
                    result = "second";
                }

                return result;
            };

            Shift.prototype.setPosition = function(position, dayOfWeek) {
                if (this.isFirstOrSecondEvaluated(dayOfWeek) === "first") {
                    this.positionForFirst = position;
                } else {
                    this.positionForSecond = position;
                }

            };

            Shift.prototype.getPosition = function(dayOfWeek) {
                if (this.isFirstOrSecondEvaluated(dayOfWeek) === "first") {
                    return this.positionForFirst;
                } else {
                    return this.positionForSecond;
                }
            };

            Shift.prototype.getWidth = function(dayOfWeek) {
                if (this.isFirstOrSecondEvaluated(dayOfWeek) === "first") {
                    return this.numberOfShiftsWideForFirst;
                } else {
                    return this.numberOfShiftsWideForSecond;
                }
            };

            Shift.prototype.setWidth = function(width, addToPrevious, dayOfWeek) {
                if (this.isFirstOrSecondEvaluated(dayOfWeek) === "first") {
                    if (addToPrevious) {
                        this.numberOfShiftsWideForFirst = this.numberOfShiftsWideForFirst + width;
                    } else {
                        this.numberOfShiftsWideForFirst = width;
                    }
                } else {
                    if (addToPrevious) {
                        this.numberOfShiftsWideForSecond = this.numberOfShiftsWideForSecond + width;
                    } else {
                        this.numberOfShiftsWideForSecond = width;
                    }
                }
            };

            Shift.prototype.clone = function() {
                var clone = new Shift();

                for (var i in this) {
                    if(this.hasOwnProperty(i)) {
                        clone[i] = this[i];
                    }
                }

                return clone;
            };

            Shift.prototype.deleteEmployee = function(employee) {
                var isDeleted = false;

                var indexOfEmployee = this.employees.indexOf(employee);

                if (indexOfEmployee !== -1) {
                    this.employees.splice(indexOfEmployee, 1);
                    isDeleted = true;
                }

                return isDeleted;
            };


            var getEmployeesFromCodes = function(codes) {
                codes = codes || [];
                var employees = [];
                codes.forEach( function (code) {
                    var employeeData = employeesData.filter( function (empData) {
                        return empData.code === code;
                    })[0];
                    if (employeeData) {
                        employees.push(new Employee(employeeData));
                    }
                });
                return employees;
            };
            var schedulesData = [
                        {
                            name: "Schema 1",
                            numberOfWeeks: 16,
                            employeesCodes: ["AA", "BB", "CC", "DD", "EE", "FF", "GG", "HH", "II", "JJ", "KK", "LL", "MM", "NN", "OO", "PP"],
                            shiftDefinitions: [
                                {
                                    code: "A1", //07:00-16:00
                                    startTime: 420,
                                    endTime: 960
                                },
                                {
                                    code: "A2",
                                    startTime: 420,
                                    endTime: 930
                                },
                                {
                                    code: "C1", //10:30-21:15
                                    startTime: 630,
                                    endTime: 1275
                                },
                                {
                                    code: "C2", //11-21
                                    startTime: 660,
                                    endTime: 1275
                                },
                                {
                                    code: "N", //21:00-07:15
                                    startTime: 1260,
                                    endTime: 435
                                },
                                {
                                    code: "Q1", //06:00-09:20
                                    startTime: 360,
                                    endTime: 560
                                }
                            ],
                            shifts: [
                                {
                                    employeeCodes: ["CC"],
                                    shiftCode: "A1",
                                    workplaceCode: "WP1",
                                    weeks: [1,2],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["AA", "BB"],
                                    shiftCode: "C1",
                                    workplaceCode: "WP2",
                                    weeks: [1,2],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: [],
                                    shiftCode: "A1",
                                    workplaceCode: "WP1",
                                    weeks: [1],
                                    dayOfWeek: 5
                                },
                                {
                                    employeeCodes: ["DD"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [2],
                                    dayOfWeek: 4
                                },
                                {
                                    employeeCodes: ["DD"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [3],
                                    dayOfWeek: 7
                                },
                                {
                                    employeeCodes: ["PP"],
                                    shiftCode: "Q1",
                                    workPlaceCode: "WP1",
                                    weeks: [1],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "C2",
                                    workPlaceCode: "WP1",
                                    weeks: [1],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [1],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [1],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [3],
                                    dayOfWeek: 1
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "A1",
                                    workPlaceCode: "WP1",
                                    weeks: [3],
                                    dayOfWeek: 2
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "C2",
                                    workPlaceCode: "WP1",
                                    weeks: [3],
                                    dayOfWeek: 2
                                },
                                {
                                    employeeCodes: ["EE"],
                                    shiftCode: "N",
                                    workPlaceCode: "WP1",
                                    weeks: [3],
                                    dayOfWeek: 2
                                }
                            ]
                        },
                        {
                            name: "Schema 2",
                            numberOfWeeks: 1,
                            employeesCodes: ["AA", "BB"],
                            shiftDefinitions: [
                                {
                                    code: "A1",
                                    startTime: 420,
                                    endTime: 960
                                }
                            ]
                        }
                    ];
            var employeesData = [
                {
                    code: "AA",
                    name: "Agneta",
                    color: "black",
                    bgColor: "#ffbaba",
                    weekWorkHours: 37,
                    employmentPercentage: 80
                },
                {
                    code: "BB",
                    name: "Bertil",
                    color: "black",
                    bgColor: "#fff3ba",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                },
                {
                    code: "CC",
                    name: "Cecilia",
                    color: "black",
                    bgColor: "#baffba",
                    weekWorkHours: 37,
                    employmentPercentage: 70
                },
                {
                    code: "DD",
                    name: "Denise",
                    color: "black",
                    bgColor: "#d1c2ff",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                },
                {
                    code: "EE",
                    name: "Erik",
                    color: "black",
                    bgColor: "#ffe2ba",
                    weekWorkHours: 37,
                    employmentPercentage: 75
                },
                {
                    code: "FF",
                    name: "Felicia",
                    color: "black",
                    bgColor: "#f3ffba",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                },
                {
                    code: "GG",
                    name: "Gustav",
                    color: "black",
                    bgColor: "#bde2fd",
                    weekWorkHours: 37,
                    employmentPercentage: 50
                },
                {
                    code: "HH",
                    name: "Hanna",
                    color: "black",
                    bgColor: "#fdb9fd",
                    weekWorkHours: 37,
                    employmentPercentage: 60
                },
                {
                    code: "II",
                    name: "Ivar",
                    color: "black",
                    bgColor: "#ffd4ba",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                },
                {
                    code: "JJ",
                    name: "Johan",
                    color: "black",
                    bgColor: "#fffcba",
                    weekWorkHours: 37,
                    employmentPercentage: 90
                },
                {
                    code: "KK",
                    name: "Kristina",
                    color: "black",
                    bgColor: "#b9fdec",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                },
                {
                    code: "LL",
                    name: "Linda",
                    color: "black",
                    bgColor: "#dfbefe",
                    weekWorkHours: 37,
                    employmentPercentage: 40
                },
                {
                    code: "MM",
                    name: "Maria",
                    color: "black",
                    bgColor: "#ffebba",
                    weekWorkHours: 37,
                    employmentPercentage: 75
                },
                {
                    code: "NN",
                    name: "Niclas",
                    color: "black",
                    bgColor: "#e1ffba",
                    weekWorkHours: 37,
                    employmentPercentage: 80
                },
                {
                    code: "OO",
                    name: "Oscar",
                    color: "black",
                    bgColor: "#c2cbfe",
                    weekWorkHours: 37,
                    employmentPercentage: 90
                },
                {
                    code: "PP",
                    name: "Pernilla",
                    color: "black",
                    bgColor: "#febad7",
                    weekWorkHours: 37,
                    employmentPercentage: 100
                }
            ];
            var workplacesData = [
                {
                    code: "WP1",
                    description: "workplace 1"
                },
                {
                    code: "WP2",
                    description: "workplace 2"
                }
            ];

            var removeEmployeeEventListeners = [];
            var removeShiftEventListeners = [];

            Polymer('one-schedule', {
                clearPlaced: function (e) {
                    this.$.clearPlacedDialog.toggle();
                },
                clearPlacedShifts: function (e) {
                    this.schedule.weekSchedules.forEach( function (weekSchedule) {
                        weekSchedule.shifts.splice(0, weekSchedule.shifts.length);
                    });
                    this.$.clearPlacedDialog.close();
                },
                clearPlacedEmployees: function (e) {
                    var shifts = this.schedule.getAllShifts();
                    shifts.forEach( function (shift) {
                        shift.employees.splice(0, shift.employees.length);
                        this.forceShiftUpdate(shift);
                    },this);
                    this.$.clearPlacedDialog.close();
                },
                minutesToHHMMString: function (minutes) {
                    var HHMMString,
                            hourPart = Math.floor(parseInt(minutes, 10) / MINUTES_IN_AN_HOUR), //make sure integer, truncate due to no integer division in javascript
                            minutePart = parseInt(minutes, 10) % MINUTES_IN_AN_HOUR; //make sure integer, modulus to get hours

                    //add leading zero if necessary
                    if (hourPart < 10)
                        hourPart = "0" + hourPart;
                    if (minutePart < 10)
                        minutePart = "0" + minutePart;

                    //format as "HH:MM" string
                    HHMMString = hourPart + ":" + minutePart;

                    return HHMMString;
                },
                randomizeEmployeeColor: function() {
                    var c1 = 255;
                    var c2 = Math.floor((Math.random() * 120) + 175);
                    var c3 = Math.floor((Math.random() * (100 - 255 + c2)) + 155);
                    if (c3 > 235) {
                        c3 = c3 - 20;
                    }

                    var colorNumbs = [c1, c2, c3];
                    var firstPick = Math.floor((Math.random() * 3));
                    var secondPick = Math.floor((Math.random() * 2));
                    var color = "rgb(" + colorNumbs.splice(firstPick, 1) + "," + colorNumbs.splice(secondPick, 1) + "," + colorNumbs.splice(0, 1) + ")";
                    this.editedEmployee.bgColor = color;
                },
                validateInput: function(event, detail, sender) {
                    if (!sender.attributes['data-type']) return;

                    var code, hours, minutes, startTime, endTime, name, wwh, ep, startTimeText, endTimeText;

                    var type = sender.attributes['data-type'].value;

                    var decorator = sender.parentNode;

                    decorator.isInvalid = false;

                    switch(type) {
                        case "employeeName":
                            name = this.editedEmployee.name;
                            name = name.trim();
                            if (name.length < 1) {
                                this.editedEmployee.nameError = "namn måste anges";
                                decorator.isInvalid = true;
                            } else if (!name.match(/[a-zA-ZåäöÅÄÖ]/g) || (name.match(/[a-zA-ZåäöÅÄÖ]/g) && name.match(/[a-zA-ZåäöÅÄÖ]/g).length < 2)) { //minst två bokstäver a-ö
                                this.editedEmployee.nameError = "inte ett giltigt namn";
                                decorator.isInvalid = true;
                            } else if (name.length > 25) {
                                this.editedEmployee.nameError = "namnet är för långt";
                                decorator.isInvalid = true;
                            }
                            break;
                        case "employeeCode":
                            code = this.editedEmployee.code;
                            code = code.trim();
                            if (code.length < 1) {
                                this.editedEmployee.codeError = "kod måste anges";
                                decorator.isInvalid = true;
                            } else if (!code.match(/^[a-zA-ZåäöÅÄÖ][a-zA-ZåäöÅÄÖ0-9\-]*$/)) { //only allow -,a-ö and 0-9, not starting with - or digit
                                this.editedEmployee.codeError = "inte en giltig kod";
                                decorator.isInvalid = true;
                            } else if (code.length > 5) {
                                this.editedEmployee.codeError = "koden är för lång";
                                decorator.isInvalid = true;
                            } else if (code !== this.editedEmployee.oldCode && this.schedule.getEmployeeByCode(code)) {
                                this.editedEmployee.codeError = "koden används redan";
                                decorator.isInvalid = true;
                            }
                            break;
                        case "employeeWeekWorkHours":
                            wwh = String(this.editedEmployee.weekWorkHours);
                            wwh = wwh.trim();
                            //if "," is used as decimal character, change it to "."
                            if (wwh.match(/,/g) && wwh.match(/,/g).length === 1) {
                                wwh = wwh.replace(',', '.');
                            }
                            wwh = parseFloat(wwh);
                            if (isNaN(wwh)) {
                                this.editedEmployee.weekWorkHoursError = "inte ett giltigt tal";
                                decorator.isInvalid = true;
                            } else {
                                this.editedEmployee.weekWorkHours = wwh;
                                if (wwh > 60 || wwh < 20) {
                                    this.editedEmployee.weekWorkHoursError = "inte ett giltigt heltidsarbetstidsmått";
                                    decorator.isInvalid = true;
                                }
                            }
                            break;
                        case "employeeEmploymentPercentage":
                            ep = String(this.editedEmployee.employmentPercentage);
                            ep = ep.trim();
                            if (ep.match(/,/g) && ep.match(/,/g).length === 1) {
                                ep = ep.replace(',', '.');
                            }
                            ep = parseFloat(ep);
                            if (isNaN(ep)) {
                                this.editedEmployee.employmentPercentageError = "inte ett giltigt tal";
                                decorator.isInvalid = true;
                            } else {
                                this.editedEmployee.employmentPercentage = ep;
                                if (ep > 100 || ep < 0) {
                                    this.editedEmployee.employmentPercentageError = "inte en giltig procentangivelse";
                                    decorator.isInvalid = true;
                                }
                            }
                            break;
                        case "shiftCode":
                            code = this.editedShift.code;
                            code = code.trim();
                            if (code.length < 1) {
                                this.editedShift.codeError = "kod måste anges";
                                decorator.isInvalid = true;
                            } else if (!code.match(/^[a-zA-ZåäöÅÄÖ][a-zA-ZåäöÅÄÖ0-9\-]*$/)) { //only allow -,a-ö and 0-9, not starting with - or digit
                                this.editedShift.codeError = "inte en giltig kod";
                                decorator.isInvalid = true;
                            } else if (code.length > 5) {
                                this.editedShift.codeError = "koden är för lång";
                                decorator.isInvalid = true;
                            } else if (code !== this.editedShift.oldCode && this.schedule.getShiftDefinitionByCode(code)) {
                                this.editedShift.codeError = "koden används redan";
                                decorator.isInvalid = true;
                            }
                            break;
                        case "shiftStartTime":
                            startTimeText = this.editedShift.startTimeText;
                            startTimeText = startTimeText.replace(/\D/g, '');
                            startTimeText = startTimeText.substr(0, 4);
                            if (startTimeText.length === 0) {
                                this.editedShift.startTimeError = "starttid måste anges";
                                decorator.isInvalid = true;
                            } else if (startTimeText.length <= 2) {
                                hours = parseInt(startTimeText);
                                if (hours < 0 || hours > 23) {
                                    this.editedShift.startTimeError = "tidsangivelsen kan inte tolkas";
                                    decorator.isInvalid = true;
                                } else {
                                    startTime = hours * MINUTES_IN_AN_HOUR;
                                }
                            } else {
                                hours = parseInt(startTimeText.substr(0, startTimeText.length - 2));
                                minutes = parseInt(startTimeText.substr(startTimeText.length - 2, 2));
                                if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                                    this.editedShift.startTimeError = "tidsangivelsen kan inte tolkas";
                                    decorator.isInvalid = true;
                                } else {
                                    startTime = hours * MINUTES_IN_AN_HOUR + minutes;
                                }
                            }
                            if (!decorator.isInvalid) {
                                this.editedShift.startTime = startTime;
                                this.editedShift.startTimeText = this.minutesToHHMMString(startTime);
                                this.editedShift.endTimeText = this.editedShift.endTimeText.replace(" (nästa dag)", "");
                                if (this.editedShift.startTime >= this.editedShift.endTime) {
                                    this.editedShift.endTimeText = this.editedShift.endTimeText + " (nästa dag)";
                                }
                            }
                            break;
                        case "shiftEndTime":
                            endTimeText = this.editedShift.endTimeText;
                            endTime;
                            endTimeText = endTimeText.replace(/\D/g, '');
                            endTimeText = endTimeText.substr(0, 4);
                            if (endTimeText.length === 0) {
                                this.editedShift.endTimeError = "sluttid måste anges";
                                decorator.isInvalid = true;
                            } else if (endTimeText.length <= 2) {
                                hours = parseInt(endTimeText);
                                if (hours < 0 || hours > 23) {
                                    this.editedShift.endTimeError = "tidsangivelsen kan inte tolkas";
                                    decorator.isInvalid = true;
                                } else {
                                    endTime = hours * MINUTES_IN_AN_HOUR;
                                }
                            } else {
                                hours = parseInt(endTimeText.substr(0, endTimeText.length - 2));
                                minutes = parseInt(endTimeText.substr(endTimeText.length - 2, 2));
                                if (hours < 0 || hours > 23 || minutes < 0 || minutes > 59) {
                                    this.editedShift.endTimeError = "tidsangivelsen kan inte tolkas";
                                    decorator.isInvalid = true;
                                } else {
                                    endTime = hours * MINUTES_IN_AN_HOUR + minutes;
                                }
                            }
                            if (!decorator.isInvalid) {
                                this.editedShift.endTime = endTime;
                                this.editedShift.endTimeText = this.minutesToHHMMString(endTime);
                                if (this.editedShift.startTime >= this.editedShift.endTime) {
                                    this.editedShift.endTimeText = this.editedShift.endTimeText + " (nästa dag)";
                                }
                            }
                            break;
                        default:
                    }
                },
                editEmployee: function(e) {
                    var employee = this.schedule.employees.filter( function (empData) {
                        return (e.target.employee && e.target.employee.code === empData.code);
                    })[0];
                    if (employee) {
                        this.editedEmployee = JSON.parse(JSON.stringify(employee)); //not wanting to alter the original object here
                        this.editedEmployee.oldCode = employee.code;
                    } else {
                        this.editedEmployee = new Employee();
                    }
                    this.$.editEmployeeDialog.toggle();
                },
                editShift: function (e) {
                    var shiftDef = this.schedule.shiftDefinitions.filter( function (shiftDef) {
                        return (e.target.shift === shiftDef);
                    })[0];
                    if (shiftDef) {
                        this.editedShift = JSON.parse(JSON.stringify(shiftDef));
                        this.editedShift.startTimeText = this.minutesToHHMMString(this.editedShift.startTime) || "";
                        this.editedShift.endTimeText = this.minutesToHHMMString(this.editedShift.endTime) || "";
                        this.editedShift.oldCode = shiftDef.code;
                    } else {
                        this.editedShift = new ShiftDefinition({startTimeText:"07:00", endTimeText:"16:00"});
                    }
                    this.$.editShiftDialog.toggle();
                },
                scheduleNames: [],
                selectSchedule: function(e) {
                //    this.$.scheduleSelector.selected = "Schema 1";

                  //  alert("selected");
                },
                openLoadScheduleDialog: function(e) {
                    this.$.loadScheduleDialog.toggle();
                },
                loadSchedule: function(e) {
                    var scheduleReference = this.$.scheduleSelector.selected;
                    this.populateSchedule(scheduleReference);
                    this.schedule.updateEmployees();
                    this.$.loadScheduleDialog.close();
                },
                editSettings: function (e) {
                    this.editedSettings = {};
                    this.editedSettings.name = this.schedule.name || "schema " + new Date().toLocaleString("sv-SE");
                    //alert(this.editedSettings.name);
                },
                saveShiftChanges: function(e) {
                    var fields = this.$.editShiftDialog.querySelectorAll("paper-input-decorator");
                    var isValidated = true;
                    for (var i = 0; i < fields.length; i++) {
                        isValidated = (fields[i].isInvalid) ? false : isValidated;
                    }

                    if (isValidated === true) {
                        var oldCode = this.editedShift.oldCode;
                        var shiftDef = this.schedule.shiftDefinitions.filter( function(shiftDef) {
                            return shiftDef.code === oldCode;
                        })[0];
                        if (!shiftDef) {
                            shiftDef = new ShiftDefinition();
                            this.schedule.shiftDefinitions.push(shiftDef);
                        }
                        shiftDef.code = this.editedShift.code;
                        shiftDef.startTime = this.editedShift.startTime;
                        shiftDef.endTime = this.editedShift.endTime;

                        var shifts = this.schedule.getShiftsByCode(oldCode);
                        shifts.forEach( function(shift) {
                            shift.startTime = shiftDef.startTime;
                            shift.endTime = shiftDef.endTime;
                            shift.code = shiftDef.code;
                            this.forceShiftUpdate(shift);
                        },this);

                        this.update++;
                        this.adjustShiftWidths();
                        this.$.editShiftDialog.close();
                    }
                },
                saveEmployeeChanges: function(e) {
                    var fields = this.$.editEmployeeDialog.querySelectorAll("paper-input-decorator");
                    var isValidated = true;
                    for (var i = 0; i < fields.length; i++) {
                        isValidated = (fields[i].isInvalid) ? false : isValidated;
                    }

                    if (isValidated === true) {
                        var oldCode = this.editedEmployee.oldCode;
                        var employee = this.schedule.employees.filter( function(employee) {
                            return employee.code === oldCode;
                        })[0];
                        if (!employee) {
                            employee = new Employee();
                            this.schedule.employees.push(employee);
                        }
                        employee.code = this.editedEmployee.code;
                        employee.name = this.editedEmployee.name;
                        employee.color = this.editedEmployee.color;
                        employee.weekWorkHours = this.editedEmployee.weekWorkHours;
                        employee.employmentPercentage = this.editedEmployee.employmentPercentage;
                        if (employee.bgColor !== this.editedEmployee.bgColor) {
                            employee.bgColor = this.editedEmployee.bgColor;
                            var shifts = this.schedule.getEmployeeShifts(employee);
                        }
                        this.schedule.updateEmployees();
                        this.forceShiftsUpdate(); //todo: some odd bug here. Updating shifts background-color every second time, for some shifts but not others.
                        this.forceShiftsUpdate(); //repeating this several times (2 is not enough) will give the desired result, but the problem is somewhere, updating many times should not be necessary
                        this.forceShiftsUpdate();
                        this.forceShiftsUpdate();
                        this.$.editEmployeeDialog.close();
                    }
                },
                returnEmptyString: function (str) {
                    return "";
                },
                toggle: function (event, detail, sender) {
                    sender.nextElementSibling.toggle();
                },
                computed: {
                },
                updated: 0,
                updatedChanged: function() {
                    //for some reason core-splitter is preventing summary element to repaint. This will force a repaint update
                    var scheduleElement = document.getElementsByTagName('one-schedule')[0];
                    scheduleElement.style.display = 'none';
                    scheduleElement.offsetHeight;
                    scheduleElement.style.display = '';

                    this.schedule.updateEmployees();
                    this.schedule.updateShifts();
                },
                pxWeekWidth: 0,
                pxWeekHeight: 0,
                schedule: {},
                ready: function () {
                    this.populateSchedule("Schema 1"); //pick first for now
                },
                domReady: function() {
                    this.scheduleNames = ["Schema 1", "Schema 2", "Granvägen 14, Sommarschema -15", "Granvägen 14, Huvudschema oktober -14"];
                    var numWeeks = this.schedule.numberOfWeeks;
                    var height = this.$.scheduleContainer.offsetHeight - 90;
                    var width = this.$.scheduleContainer.offsetWidth - 70;

                    if (numWeeks === 1) {
                        this.pxWeekWidth = width;
                        this.pxWeekHeight = height;
                    } else if (numWeeks === 2) {
                        this.pxWeekWidth = width / 2 - 5; //compensate for 10 extra px between weekSchedules
                        this.pxWeekHeight = height;
                    } else if (numWeeks === 3 || numWeeks === 4) {
                        this.pxWeekWidth = width / 2 - 5;
                        this.pxWeekHeight = height / 2 - 5;
                    } else if (numWeeks >= 5 && numWeeks <= 6) {
                        this.pxWeekWidth = width / 3 - 7;
                        this.pxWeekHeight = height / 2 - 5;
                    } else if (numWeeks >= 7 && numWeeks <= 9) {
                        this.pxWeekWidth = width / 3 - 7;
                        this.pxWeekHeight = height / 3 - 7;
                    } else if (numWeeks >= 10 && numWeeks <= 12) {
                        this.pxWeekWidth = width / 4 - 8;
                        this.pxWeekHeight = height / 3 - 7;
                    } else if (numWeeks >= 13 && numWeeks <= 16) {
                        this.pxWeekWidth = width / 4 - 8;
                        this.pxWeekHeight = height / 4 - 8;
                    }
                    this.updated++;
                },
                populateSchedule: function(scheduleName) {
                    var scheduleData = schedulesData.filter(function (schedule) {
                        return schedule.name === scheduleName;
                    })[0];

                    if (scheduleData === null) return;

                    this.schedule = new Schedule(scheduleData);

                    this.adjustShiftWidths();
                    this.forceShiftsUpdateForAllEmployees();
                },
                adjustShiftWidths: function () {
                    for (var currentWeekIndex = 0; currentWeekIndex < this.schedule.weekSchedules.length; currentWeekIndex++) {
                        for (var dayOfWeek = 1; dayOfWeek <= 7; dayOfWeek++) {
                            var currentShifts = this.schedule.weekSchedules[currentWeekIndex].shifts.filter( function(shift) {
                                return ((shift.week === currentWeekIndex + 1 && shift.dayOfWeek === dayOfWeek && shift.isFirstOrSecondEvaluated(dayOfWeek) === "first") ||
                                (shift.week === currentWeekIndex + 1 && shift.dayOfWeek === dayOfWeek - 1 && shift.isFirstOrSecondEvaluated(dayOfWeek) === "second") ||
                                (shift.week !== currentWeekIndex + 1 && shift.dayOfWeek === 7 && dayOfWeek === 1 && shift.isFirstOrSecondEvaluated(dayOfWeek) === "second"));
                            });

                            currentShifts = currentShifts.sort(function(a,b) {
                                // if shift spans over two days, and shift's dayOfWeek is not equal to current day's dayOfWeek, set startTime to 0.
                                // if shift spans over two days, and shift's dayOfWeek is equal to current day's dayOfWeek, set endTime to 1440.
                                // sort on 1) startTime, ascending, 2) endTime, ascending
                                var result = 0;
                                var aStartTime = a.getAdjustedStartTime(dayOfWeek);
                                var aEndTime = a.getAdjustedEndTime(dayOfWeek);
                                var bStartTime = b.getAdjustedStartTime(dayOfWeek);
                                var bEndTime = b.getAdjustedEndTime(dayOfWeek);
                                if (aStartTime !== bStartTime) {
                                    result = aStartTime - bStartTime;
                                } else {
                                    result = aEndTime - bEndTime;
                                }
                                return result;
                            });


                            var currentShiftIndex;
                            for (currentShiftIndex = 0; currentShiftIndex < currentShifts.length; currentShiftIndex++) {
                                var currentShift = currentShifts[currentShiftIndex];
                                var currentStartTime = currentShift.getAdjustedStartTime(dayOfWeek);
                                var currentEndTime = currentShift.getAdjustedEndTime(dayOfWeek);

                                var timeCollidingShifts = currentShifts.filter( function(shift) {
                                    if (shift === currentShift) return true;
                                    var otherStartTime = shift.getAdjustedStartTime(dayOfWeek);
                                    var otherEndTime = shift.getAdjustedEndTime(dayOfWeek);
                                    var isColliding =  ((otherStartTime <= currentStartTime && otherEndTime > currentStartTime) || (otherStartTime > currentStartTime && otherStartTime < currentEndTime));
                                    var isLeftColliding = (isColliding && currentShifts.indexOf(currentShift) > currentShifts.indexOf(shift));
                                    return isLeftColliding;
                                });

                                currentShift.setWidth(timeCollidingShifts.length, false, dayOfWeek);
                                timeCollidingShifts.forEach( function (shift) {
                                    if (shift.getWidth(dayOfWeek) < timeCollidingShifts.length) {
                                        shift.setWidth(1, true, dayOfWeek);
                                    }
                                });

                                var spaceFound = false;
                                var shiftPosition;
                                var currentShiftWidth = currentShift.getWidth(dayOfWeek);
                                var shiftWidth = currentShiftWidth;
                                var currentShiftPosition = currentShift.getPosition(dayOfWeek);
                                while (!spaceFound && shiftWidth < 10) { //10 to prevent an infinite loop if a bug is encountered
                                    for (shiftPosition = 1; shiftPosition <= shiftWidth; shiftPosition++) {
                                        var spaceCollidingShifts = timeCollidingShifts.filter( function (shift) {
                                            if (shift === currentShift) return false;
                                            var otherShiftPosition = shift.getPosition(dayOfWeek);
                                            var isColliding = (otherShiftPosition === shiftPosition && currentShifts.indexOf(currentShift) > currentShifts.indexOf(shift));
                                            return isColliding;
                                        });
                                        if (spaceCollidingShifts.length === 0) {
                                            spaceFound = true;
                                            currentShiftPosition = shiftPosition;
                                            break;
                                        }
                                    }
                                    if (shiftWidth === currentShiftPosition && !spaceFound) {
                                        shiftWidth = shiftPosition + 1;
                                    }
                                }
                                if (currentShiftPosition > shiftWidth) {
                                    shiftWidth = currentShiftPosition;
                                }
                                currentShift.setWidth(shiftWidth, false, dayOfWeek);
                                currentShift.setPosition(currentShiftPosition, dayOfWeek);
                            }
                        }
                    }
                },
                dragInfo: {},
                dragInfoChanged: function(oldValue, newValue) {
                    var i, buttons;
                    if (Object.keys(this.dragInfo).length === 0) { //check if this.dragInfo is an empty object (no object is dragged -> cursor should be visible)
                        this.style.cursor = "default";
                        this.$.paperSlider.style.cursor = "default";

                        buttons = this.shadowRoot.querySelectorAll("paper-button");
                        for (i = 0; i < buttons.length; i++) {
                            buttons[i].style.cursor = "pointer";
                        }
                    } else {
                        this.style.cursor = "none";
                        this.$.paperSlider.style.cursor = "none";

                        buttons = this.shadowRoot.querySelectorAll("paper-button");
                        for (i = 0; i < buttons.length; i++) {
                            buttons[i].style.cursor = "none";
                        }
                    }

                    if (newValue && newValue.event && newValue.event.type === "track") {
                        if (newValue.draggedItem.id === "oneShift") {
                            this.disablePointerEventsForOneShifts();
                        }
                    }
                    if (oldValue && oldValue.event && oldValue.event.type === "trackend") {
                        //if an employee is dropped...
                        if (oldValue.draggedItem.id === "oneEmployee") {
                            this.moveEmployee(oldValue);
                        } else if (oldValue.draggedItem.id === "oneShift") {
                            this.enablePointerEventsForOneShifts();
                            this.moveShift(oldValue);
                        }
                    }
                },
                forceShiftUpdate: function(shift) {

                    var clonedShift = shift.clone();

                    this.schedule.weekSchedules.forEach( function (weekSchedule) {
                        var shiftIndex = weekSchedule.shifts.indexOf(shift);
                        if (shiftIndex !== -1) {
                            weekSchedule.shifts.splice(shiftIndex, 1);
                            weekSchedule.shifts.push(clonedShift);
                        }
                    });
                },
                forceShiftsUpdate: function() {
                    this.schedule.weekSchedules.forEach( function (weekSchedule) {
                        weekSchedule.shifts.forEach( function (shift) {
                            this.forceShiftUpdate(shift);
                        },this);
                    },this)
                },
                forceShiftsUpdateForEmployee: function(employee) {
                    var daysInSchedule = this.schedule.numberOfWeeks * DAYS_IN_A_WEEK;
                    var schedule = this.schedule;
                    var breakPointTime;
                    if (employee.hasOwnBreakPoint === true) {
                        breakPointTime = employee.breakPointTime;
                    } else {
                        breakPointTime = schedule.breakPointTime;
                    }

                    var shifts = schedule.getShiftsByEmployee(employee);

                    //each day a new rest period is starting at the given breakPointTime. each rest period is 24 hours.
                    //The goal is to find out if this rest period has an 11 hour long period without placed work for the employee.

                    //Loop through each day in the schedule
                    for (var dayRestPeriodDay = 1; dayRestPeriodDay <= daysInSchedule; dayRestPeriodDay++) {
                        //get the shifts which fully or partly exist in the (24 hour) dayRestPeriod belonging to the dayRestPeriodDay
                        var shiftsInRestPeriod = shifts.filter( function (shift) {
                            var day = shift.dayOfWeek + (shift.week - 1) * DAYS_IN_A_WEEK;
                            var isInRestPeriod = false;
                            if ((dayRestPeriodDay === day && shift.startTime < shift.endTime && (shift.startTime >= breakPointTime || shift.endTime > breakPointTime || shift.endTime === 0)) ||
                                    (dayRestPeriodDay === day - 1 && shift.startTime < shift.endTime && (shift.startTime < breakPointTime)) ||
                                    (dayRestPeriodDay === day && shift.startTime >= shift.endTime && (shift.startTime < breakPointTime || shift.endTime <= breakPointTime))) {
                                isInRestPeriod = true;
                            }

                            return isInRestPeriod;
                        });

                        if (shiftsInRestPeriod.length > 0) {
                            console.log("restperiodday: " + dayRestPeriodDay);
                            console.log(shiftsInRestPeriod);
                        }

                        //create the rest period of 24 hours for the current day...
                        var restTimes = [];
                        restTimes.push({ startTime: breakPointTime, endTime: breakPointTime + MINUTES_IN_A_DAY});

                        //...and as placed shifts overlaps the rest period, split the rest period up and keep the periods with the periods which has not any placed work
                        shiftsInRestPeriod.forEach( function (shift) {
                            var day = shift.dayOfWeek + (shift.week - 1) * DAYS_IN_A_WEEK;
                            //eftersom både 24-timmarsperioden och turerna kan spänna över två dygn
                            //behöver turernas start- och sluttider eventuellt anpassas så att de
                            //överensstämmer med motsvarande start- och sluttider för viloperioderna
                            //inom 24-timmarsperioden.
                            //todo: adjust report
                            var shiftStartTime = shift.startTime;
                            var shiftEndTime = shift.endTime > shift.startTime ? shift.endTime : shift.endTime + MINUTES_IN_A_DAY;
                            if (day === dayRestPeriodDay + 1) {
                                shiftStartTime += MINUTES_IN_A_DAY;
                                shiftEndTime += MINUTES_IN_A_DAY;
                            }
                            var alteredRestTimes = [];

                            restTimes.forEach( function (restTime) {
                                if (shiftStartTime > restTime.startTime && shiftEndTime < restTime.endTime) {
                                    alteredRestTimes.push({ startTime: restTime.startTime, endTime: shiftStartTime});
                                    alteredRestTimes.push({ startTime: shiftEndTime, endTime: restTime.endTime});
                                } else if (shiftStartTime <= restTime.startTime && shiftEndTime > restTime.startTime && shiftEndTime < restTime.endTime) {
                                        alteredRestTimes.push({ startTime: shiftEndTime, endTime: restTime.endTime});
                                } else if (shiftEndTime >= restTime.endTime && shiftStartTime < restTime.endTime && shiftStartTime > restTime.startTime) {
                                        alteredRestTimes.push({ startTime: restTime.startTime, endTime: shiftStartTime});
                                } else if (shiftStartTime <= restTime.startTime && shiftEndTime >= restTime.endTime) {
                                    //do nothing
                                } else {
                                    alteredRestTimes.push(restTime);
                                }
                            });

                            restTimes = alteredRestTimes;
                        });

                        //check if any of the rest periods contains 11 hours
                        var hasDayRestPeriod = restTimes.some( function (restTime) {
                            return (restTime.endTime - restTime.startTime) > 11 * MINUTES_IN_AN_HOUR;
                        });

                        //finally set shifts fulfills day rest constraint to false, if the current rest period
                        //does not contain 11 hours rest.
                        shiftsInRestPeriod.forEach( function (shift) {
                            if (!hasDayRestPeriod) {
                                shift.fulfillsDayRestConstraint = false;

                            }
                        });
                    }
                },
                forceShiftsUpdateForAllEmployees: function() {
                    //presuppose shifts fullfills day rest constraint
                    this.schedule.weekSchedules.forEach( function (weekSchedule) {
                        weekSchedule.shifts.forEach( function (shift) {
                            shift.fulfillsDayRestConstraint = true;
                        });
                    });
                    //check for day rest constraint and set shift's fulfillsDayRestConstraint to false for shifts
                    //which have employee(s) which atleast one is not fulfilling day rest constraint
                    this.schedule.employees.forEach( function (employee) {
                        this.forceShiftsUpdateForEmployee(employee);
                        console.log("checked employee:", employee.code);
                    },this);
                },
                moveEmployee: function(dragInfo) {
                    var draggedFromShift,
                        draggedEmployee;

                    //if the target is a "oneShift"...
                    if (dragInfo.dropTarget && dragInfo.dropTarget.id === "oneShift" && !dragInfo.dropTarget.classList.contains("shiftData")) {
                        //if this "oneShift" does not already have the "employee"
                        if (dragInfo.dropTarget.shift.employees.indexOf(dragInfo.draggedItem.employee) === -1) {
                            //add the "employee" to the "oneShift")
                            dragInfo.dropTarget.shift.employees.push(dragInfo.draggedItem.employee);

                            var clonedDropTargetShift = dragInfo.dropTarget.shift.clone();

                            this.schedule.weekSchedules.forEach( function (weekSchedule) {
                                var shiftIndex = weekSchedule.shifts.indexOf(dragInfo.dropTarget.shift);
                                if (shiftIndex !== -1) {
                                    weekSchedule.shifts.splice(shiftIndex, 1);
                                    weekSchedule.shifts.push(clonedDropTargetShift);
                                }
                            });

                            //if the "employee" was dragged from (another) "oneShift"
                            if (dragInfo.draggedItem.offsetParent.id === "oneShift") {
                                //remove the "employee" from that "oneShift"
                                draggedFromShift = dragInfo.draggedItem.offsetParent.shift;
                                draggedEmployee = dragInfo.draggedItem.employee;
                                draggedFromShift.deleteEmployee(draggedEmployee);
                                this.forceShiftUpdate(draggedFromShift);
                            }
                        }
                    } else if (dragInfo.dropTarget && dragInfo.dropTarget.id === "oneDelete") {
                        draggedEmployee = dragInfo.draggedItem.employee;

                        //if dragged from a oneShift, delete it
                        if (dragInfo.draggedItem.offsetParent.id === "oneShift") {
                            draggedFromShift = dragInfo.draggedItem.offsetParent.shift;
                            if (draggedEmployee.constructor.name === "Employee") {
                                if (draggedFromShift.deleteEmployee(draggedEmployee)) {
                                    this.forceShiftUpdate(dragInfo.draggedItem.offsetParent.shift);
                                }
                            }
                        //else, (dragged from board), ask user if wants to proceed, then delete it + all occurrences on shifts
                        } else {
                            var deleteEmployeeCompletely = function(e) {
                                this.schedule.employees.splice(this.schedule.employees.indexOf(draggedEmployee), 1);
                                this.schedule.weekSchedules.forEach( function(weekSchedule) {
                                    var alterShifts = [];
                                    weekSchedule.shifts.forEach( function (shift) {
                                        if (shift.employees.indexOf(draggedEmployee) !== -1) {
                                            if (alterShifts.indexOf(shift) === -1) {
                                                alterShifts.push(shift);
                                            }
                                        }
                                    },this);
                                    alterShifts.forEach( function(shift) {
                                        shift.deleteEmployee(draggedEmployee);
                                        this.forceShiftUpdate(shift);
                                    },this);
                                }, this);
                                this.$.deleteEmployeeDialog.close();
                                //todo: message
                            }.bind(this);

                            removeEmployeeEventListeners.forEach( function (eventListener) {
                                this.$.deleteEmployeeButton.removeEventListener('click', eventListener, false);
                            },this);

                            this.$.deleteEmployeeDialog.toggle();
                            this.$.deleteEmployeeButton.addEventListener('click', deleteEmployeeCompletely, false);
                            removeEmployeeEventListeners.push(deleteEmployeeCompletely);
                        }
                    }
                    this.updated++;
                    this.adjustShiftWidths();
                    this.forceShiftsUpdateForAllEmployees(); //todo: probably just employees of the moved to or moved from shift needs to be updated.
                },
                moveShift: function(dragInfo) {
                    var draggedShift;

                    //if the target is a "weekDay"...
                    if (dragInfo.dropTarget && dragInfo.dropTarget.id === "weekDay") {

                        var dropWeekDayIndex = parseInt(dragInfo.dropTarget.attributes['weekDayIndex'].value);

                        var dropOneWeek = dragInfo.dropTarget.parentElement.offsetParent;
                        var dropShifts = dropOneWeek.data.shifts;
                        draggedShift =  dragInfo.draggedItem.shift;
                        //if this week does not already have the "oneShift" or if this week, but not this "weekDay" have the "oneShift"
                        if (dropShifts.indexOf(draggedShift) === -1 || (draggedShift.dayOfWeek !== dropWeekDayIndex + 1 || draggedShift.dayOfWeek - 7 !== dropWeekDayIndex + 1 )) {
                            draggedShift.week = dropOneWeek.weekNumber;
                            draggedShift.dayOfWeek = dropWeekDayIndex + 1;

                            var originOneWeek = dragInfo.draggedItem.parentElement.offsetParent;

                            //sometimes one shift spans over several weeks, fetch all weeks that holds the dragged shift.
                            var weekSchedulesWithShift = this.schedule.weekSchedules.filter( function (weekSchedule) {
                                return weekSchedule.shifts.indexOf(draggedShift) !== -1;
                            });
                            //...remove this shift from this/these weeks.
                            weekSchedulesWithShift.forEach( function(weekSchedule) {
                                var shiftIndex = weekSchedule.shifts.indexOf(draggedShift);
                                if (shiftIndex !== -1) {
                                    weekSchedule.shifts.splice(shiftIndex, 1);
                                }
                            });
                            //add the shift to the week it is dragged to. Make a copy to trigger a UI update.
                            var dropWeekSchedule = this.schedule.weekSchedules[dropOneWeek.weekNumber - 1];
                            var draggedShiftClone;
                            if (draggedShift.constructor.name === "Shift") {
                                draggedShiftClone = draggedShift.clone();
                            } else if (draggedShift.constructor.name === "ShiftDefinition") {
                                draggedShiftClone = draggedShift.createShift();
                            }
                            dropWeekSchedule.shifts.push(draggedShiftClone);

                            //if the shift is dragged to a Sunday and the shift spans over two days, also add it to next week's shifts.
                            if (draggedShift.dayOfWeek === 7 && draggedShift.endTime <= draggedShift.startTime) {
                                var nextDropWeekSchedule;
                                //if next week is within the number of weeks, set next week to the dragged-to week + 1
                                if (dropOneWeek.weekNumber < this.schedule.numberOfWeeks) {
                                    nextDropWeekSchedule = this.schedule.weekSchedules[dropOneWeek.weekNumber - 1 + 1];
                                    //...or else, there are no more weeks, set next week to the first week
                                } else {
                                    nextDropWeekSchedule = this.schedule.weekSchedules[0];
                                }
                                //add a copy to the next week. Make a copy to trigger a UI update.
                                nextDropWeekSchedule.shifts.push(draggedShiftClone);
                            }
                        }
                    } else if (dragInfo.dropTarget && dragInfo.dropTarget.id === "oneDelete") {
                        //delete shift from week or shiftDefinition from board
                        draggedShift =  dragInfo.draggedItem.shift;
                        if (draggedShift.constructor.name === "Shift") {
                            if (this.schedule.deleteShift(draggedShift)) {
                            } else {
                                //no shift deleted
                            }
                        } else if (draggedShift.constructor.name === "ShiftDefinition") {
                            var deleteShiftCompletely = function(e) {
                                var code = draggedShift.code;
                                if (this.schedule.deleteShiftDefinition(draggedShift)) {

                                    this.schedule.weekSchedules.forEach( function(weekSchedule) {
                                        var shiftsToRemove = [];
                                        weekSchedule.shifts.forEach( function (shift) {
                                            if (shift.code === code) {
                                                shiftsToRemove.push(shift);
                                            }
                                        });
                                        shiftsToRemove.forEach( function(shift) {
                                            var shiftIndex = weekSchedule.shifts.indexOf(shift);
                                            weekSchedule.shifts.splice(shiftIndex, 1);
                                        });
                                        shiftsToRemove = []; //reset
                                    }, this);
                                    this.$.deleteShiftDialog.close();
                                    //todo: message
                                } else {
                                    //no shift definition nor shifts were deleted
                                }
                                this.updated++;
                                this.adjustShiftWidths(); //recalculate the shifts' widths.
                            }.bind(this);

                            removeShiftEventListeners.forEach( function (eventListener) {
                                this.$.deleteShiftButton.removeEventListener('click', eventListener, false);
                            },this);

                            this.$.deleteShiftDialog.toggle();
                            this.$.deleteShiftButton.addEventListener('click', deleteShiftCompletely, false);
                            removeShiftEventListeners.push(deleteShiftCompletely);
                        }
                    }
                    this.updated++;
                    this.adjustShiftWidths(); //recalculate the shifts' widths.
                    this.forceShiftsUpdateForAllEmployees(); //todo: just employees of the moved shift needs to be updated. create such function.
                },
                disablePointerEventsForOneShifts: function() {
                    var els = document.querySelectorAll('* /deep/ #oneShift');
                    for (var i = 0; i < els.length; i++) {
                        els[i].style.pointerEvents = "none";
                    }
                },
                enablePointerEventsForOneShifts: function() {
                    var els = document.querySelectorAll('* /deep/ #oneShift');
                    for (var i = 0; i < els.length; i++) {
                        els[i].style.pointerEvents = "auto";
                    }
                }
            });
        })();

    </script>
</polymer-element>